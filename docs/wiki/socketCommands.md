# Socket 多元通信协议说明

## Node - Java

Node 进程与 Java 进程均启动一个 socket server，分别开放端口 9233 与 9234。

它们之间的通讯采用发送类似 minecraft 指令的形式，并且指令十分少。

下面是所有指令的列表：

| 命令名 | 参数表 | 说明 |
| :- | :- | :- |
| log | <输出的内容> | 向对方投递自己产生的日志文本；这么做的目的是为了能双向收集并备份日志，如果其中一方崩溃了，另一方就可以拿出收集的日志自动上传到服务器了。 |
| execute | <路由> <包名> <具体子命令> \[具体参数...\] | 请求执行某个模块下注册的某个指令。路由为一个类似```XXX->XXX```格式的文本，箭头左侧为发送者自己的平台类型，箭头右侧为目标平台类型；包名可以理解为插件名。例如，从 Node 向 Java 发送请求启用托盘图标，托盘图标显示用的插件 tray 的启动指令为 start，不需要参数，那么就传递 ```execute node->H5 tray start```。 |
| data | <路由> <包名> <具体子命令> \[返回的数据...\] | 这是为了回复对方 execute 请求的数据而出现的指令，用于返回对方某个具体指令请求的数据；规则与 execute 指令大致相同，但它是用于回复命令而不是执行命令的。data 指令发送时源的箭头应当是向左的，以表示这是一个“回调函数”一样的存在，目的是为了发送对方所需的信息而不是请求信息。 |
| system | <路由> \<call\|receive\|command\> \[验证文本\|命令\] | 这是特殊版本的 execute，它并不用于执行对方某个包下的指令，而是用于与对方平台握手，确保连接到的对方能够正确识别命令、是客户端的一部分。call 为发起验证请求，receive 为回复验证请求，command 为调用对方提供的系统指令（例如 stop 可以请求对方关闭其进程）。验证文本为一串请求者的平台版本编号，不论是请求还是回复都应当填写发送者自己的版本信息，例如```node-0.2.6```或```H5-0.3.0```。 |
| callback | \<got\|fail\> <路由> <包名> <具体子命令> | 在发起方发送了指令后，接收方应当立即作出响应，告知对方这个指令是否被接下了。如果指令能被对应的包识别并接下来，就回复个带对应命令的```callback got XXX<-XXX XXX XXX```并立即断开此次的连接，否则回复```callback fail XXX<-XXX```。回复时带的源的箭头正好与发送者给的箭头方向反过来，例如发送者为 node，接收者为 java，那么这个 callback 指令回复的源文本就是 ```node<-java```。 |

上述的 execute 与 callback 两个指令是一对，一次 execute 必定要伴随着一个 callback。system 指令与 log 指令的执行不用回复 callback 指令。

不过，你可能会对这种机制有所疑问，如果我想从对方套个数据（例如剪贴板数据、网页抓包得来的文本），但对面只回复个```callback got```，怎么获取数据？解决方法很简单，也符合异步调用的机制：一方在 execute 后就可以先在那里等待，直到另一方完成了数据的处理后，可以主动向对方调用一次 data，这样子对方就能够接收到它想要的数据了。

例如，我想让 Node 端向 Java 端请求剪贴板的数据，那么 Node 端先主动请求：

```execute node->java clipboard get```

Java 端在接收到请求后立即回复：

```callback got node<-java clipboard get```

然后 Node 端在那里等待，直到 Java 端的数据获取完成，由 Java 端主动发起请求：

```data node<-java clipboard get [...txt...]```

这时候 Node 就成功地拿到了数据，但不能忘了回复一下：

```callback got node->java data clipboard get```

这一个命令就算完成了。

源有以下几种：
- H5 —— HTML5 UI 客户端，可直接在网页上运行，也可以以 Electron 等框架运行，它们不会使用本地方法。
- java —— java 服务端。
- node —— node 服务端。
