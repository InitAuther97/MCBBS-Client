# Socket 多元通信协议说明

## Node - Java

Node 进程与 Java 进程均启动一个 socket server，分别开放端口 9233 与 9234。

它们之间的通讯采用发送类似 minecraft 指令的形式，并且指令十分少。

下面是所有指令的列表：

| 命令名 | 参数表 | 说明 |
| :- | :- | :- |
| log | <输出的内容> | 向对方投递自己产生的日志文本；这么做的目的是为了能双向收集并备份日志，如果其中一方崩溃了，另一方就可以拿出收集的日志自动上传到服务器了。 |
| execute | <包名> <具体子命令> \[具体参数...\] | 让对方执行某个模块下注册的某个指令；包名可以理解为插件名，例如托盘图标显示用的插件 tray 的启动指令为 start，不需要参数，那么就传递 ```execute tray start```。 |
| system | \<call\|receive\|stop\> \[验证文本\] | 这是特殊版本的 execute，它并不用于执行对方某个包下的指令，而是用于与对方建立可信任的加密通信，进而互相进行加密传输。验证文本将为后续通讯时交换文本的加密公钥。call 为发起请求，receive 为接收请求，stop 为请求对方结束自己的进程。一旦一方发起 call，另一方返回的便是使用传来的公钥加密后的数据，原理类似 HTTPS 的握手，具体的做法会在后文详细描述。 |
| callback | \<got\|fail\> \[额外信息\] | 在发起方发送了指令后，接收方应当立即作出响应，告知对方这个指令是否被接下了。如果指令能被对应的包识别并接下来，就回复个```callback got```并立即断开此次的连接，否则回复```callback fail```。 |

上述的 execute 与 callback 两个指令是一对，一次 execute 必定要伴随着一个 callback。system 指令与 log 指令的执行不用回复 callback 指令。

不过，你可能会对这种机制有所疑问，如果我想从对方套个数据（例如剪贴板数据、网页抓包得来的文本），但对面只回复个```callback got```，怎么获取数据？解决方法很简单，也符合异步调用的机制：一方在 execute 后就可以先在那里等待，直到另一方完成了数据的处理后，可以主动向对方也调用一次 execute，这样子对方就能够接收到它想要的数据了。

例如，我想让 Node 端向 Java 端请求剪贴板的数据，那么 Node 端先主动请求：

```execute clipboard get```

Java 端在接收到请求后立即回复：

```callback got```

然后 Node 端在那里等待，直到 Java 端的数据获取完成，由 Java 端主动发起请求：

```execute clipboard getCallback [...txt...]```

这时候 Node 就成功地拿到了数据，但不能忘了回复一下：

```callback got```

这一个命令就算完成了。

## HTML5 - Native Server

> 待编辑，这里使用的是 web socket

## 加密数据传输前的握手协议

> 待编辑，这里使用 RSA 生成密钥对，双方互换公钥
> 一方（甲） call 并带上自己的公钥，另一方（乙）也 call 并带上自己（乙）的公钥加密发回去，此方（甲）在解密得到对方（乙）的公钥后以 receive 随机生成一个数据用对方（乙）的公钥加密发出去，最后另一方（乙）解密得到数据，将这个原始数据再以对方（甲）的公钥加密发回去，此时如果对方（甲）以自己的公钥加密发回个```callback got```就视为握手成功，否则明文回个```callback fail```。
> RSA 公钥文本为一个很大的十进制素数文本。